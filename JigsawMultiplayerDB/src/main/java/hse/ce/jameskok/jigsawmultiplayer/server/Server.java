package hse.ce.jameskok.jigsawmultiplayer.server;

import hse.ce.jameskok.jigsawmultiplayer.GameResult;
import hse.ce.jameskok.jigsawmultiplayer.PlayerStatus;
import hse.ce.jameskok.jigsawmultiplayer.ResultType;
import hse.ce.jameskok.jigsawmultiplayer.model.FigureGenerator;
import hse.ce.jameskok.jigsawmultiplayer.model.Shape;

import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Properties;

/**
 * Server part of game.
 */
final class Server {
    private final boolean isCooperative;
    private final int timeLimit;
    private final ServerSocket serverSocket;
    private final ServerRegistrar registrar;
    private ArrayList<Shape> shapes = new ArrayList<>();
    private final ArrayList<ClientHandler> clientHandlers = new ArrayList<>();
    private Statement statement;
    private static final String dbName = "Test2";

    /**
     * Init server.
     *
     * @param port          port
     * @param isCooperative is game cooperative
     * @param timeLimit     limit for one game in seconds
     * @throws IOException occurs when a connection cannot be established
     */
    Server(int port, boolean isCooperative, int timeLimit) throws IOException {
        this.isCooperative = isCooperative;
        this.timeLimit = timeLimit;
        serverSocket = new ServerSocket(port);
        registrar = new ServerRegistrar(serverSocket, this);
        registrar.start();
        String request = "CREATE TABLE " + dbName + " (" +
                "UserID INTEGER PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 0, INCREMENT BY 1)," +
                "Username CHAR(20)," +
                "Date TIMESTAMP," +
                "Score INTEGER," +
                "Duration INTEGER" +
                ")";
        try {
            Connection connection = connectToDataBase();
            statement = connection.createStatement();
            statement.executeUpdate(request);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Start game if it is possible.
     */
    void startGame() {
        if (clientHandlers.size() == 0) {
            return;
        }
        if (!isCooperative) {
            generateShapes();
            clientHandlers.get(0).startGame(null);
        } else if ((clientHandlers.size() == 2) && (
                clientHandlers.get(0).getStatus() == PlayerStatus.READY &&
                        clientHandlers.get(1).getStatus() == PlayerStatus.READY)
        ) {
            generateShapes();
            clientHandlers.get(0).startGame(clientHandlers.get(1).getPlayerName());
            clientHandlers.get(1).startGame(clientHandlers.get(0).getPlayerName());
        }
    }

    /**
     * Restart game if it is possible.
     */
    synchronized void restartGame() {
        boolean ready = true;
        for (var client : clientHandlers) {
            if (client.getStatus() != PlayerStatus.READY) {
                ready = false;
                break;
            }
        }
        if (ready) {
            startGame();
        }
    }

    /**
     * Determine the winner.
     */
    synchronized void processResults() {
        if (isCooperative && clientHandlers.size() == 2) {
            var firstClient = clientHandlers.get(0);
            var secondClient = clientHandlers.get(1);

            if ((firstClient.getStatus() != PlayerStatus.IN_GAME) && (secondClient.getStatus() != PlayerStatus.IN_GAME)) {
                GameResult result1 = firstClient.getResult(), result2 = secondClient.getResult();
                int score1 = result1.score();
                int score2 = result2.score();
                int time1 = result1.duration();
                int time2 = result2.duration();
                if (score1 == score2 && time1 == time2) {
                    firstClient.sendResult(ResultType.TIE);
                    secondClient.sendResult(ResultType.TIE);
                } else {
                    if (score1 > score2 || (score1 == score2) && (time1 < time2)) {
                        firstClient.sendResult(ResultType.WIN);
                        secondClient.sendResult(ResultType.LOSE);
                    } else {
                        firstClient.sendResult(ResultType.LOSE);
                        secondClient.sendResult(ResultType.WIN);
                    }
                }
            }
        }
    }

    /**
     * Get maximum of game duration.
     *
     * @return max time for one game in seconds
     */
    int getTimeLimit() {
        return timeLimit;
    }


    /**
     * Get all connected client handlers
     *
     * @return array of active client handlers
     */
    ArrayList<ClientHandler> getClientHandlers() {
        return clientHandlers;
    }

    void closeServer() {
        registrar.interrupt();
        try {
            serverSocket.close();
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Get generated figure shape by turn number.
     *
     * @param idx turn number
     * @return shape of figure
     */
    Shape getShape(int idx) {
        return shapes.get(idx % shapes.size());
    }

    /**
     * Get number of maximum possible players on server at the same time.
     *
     * @return maximum number of players
     */
    int maxPlayers() {
        return isCooperative ? 2 : 1;
    }

    /**
     * Report about win cause of enemy came.
     */
    void setAutoWin() {
        if (!clientHandlers.isEmpty()) {
            clientHandlers.get(0).sendAutoWin();
        }
    }

    /**
     * Save result to database.
     *
     * @param result game result
     */
    synchronized void dumbToDB(GameResult result) {
        String request = "INSERT INTO " + dbName +
                " (Username, Date, Score, Duration) VALUES (" + result.getFormattedString() + ")";
        try {
            statement.executeUpdate(request);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }

    /**
     * Load 10 best games from database.
     *
     * @return list of results
     */
    ArrayList<GameResult> getBestPlayers() {
        String request = "SELECT * FROM " + dbName +
                " ORDER BY Score DESC, Duration ASC, Date DESC OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY";
        ArrayList<GameResult> result = new ArrayList<>();
        try (ResultSet set = statement.executeQuery(request)) {
            while (set.next()) {
                String username = set.getString("Username");
                LocalDateTime date = set.getTimestamp("Date").toLocalDateTime();
                int duration = set.getInt("Duration");
                int score = set.getInt("Score");
                result.add(new GameResult(username, date, duration, score));
            }
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        return result;
    }

    /**
     * Init array of random shapes.
     */
    private void generateShapes() {
        shapes = new ArrayList<>();
        int nShapes = 30;
        for (int i = 0; i < nShapes; ++i) {
            shapes.add(FigureGenerator.getFigure());
        }
    }

    /**
     * Connect to database.
     * @return connection
     * @throws IOException occurs when there are problems with properties file
     * @throws SQLException occurs when there are problems with database
     */
    private Connection connectToDataBase() throws IOException, SQLException {
        var props = new Properties();
        try (InputStream in = Server.class.getResourceAsStream("database.properties")) {
            props.load(in);
        }
        String drivers = props.getProperty("jdbc.drivers");
        if (drivers != null) System.setProperty("jdbc.drivers", drivers);

        String url = props.getProperty("jdbc.url");
        String username = props.getProperty("jdbc.username");
        String password = props.getProperty("jdbc.password");

        return DriverManager.getConnection(url, username, password);
    }

}
